-- RECORD & COLLECTION
-- RECORD : 서로 다른 타입들을 하나로 묶은 타입
-- COLLECTION : 같은 타입들을 하나로 묶은 타입

-- RECORD
DECLARE
	-- RECORD타입 생성
 	TYPE REC_DEPT IS RECORD(
 	DEPT_ID NUMBER(4),
 	DEPT_NAME VARCHAR2(30)
	);
	-- RECORD타입 변수 생성
	V_REC_DEPT REC_DEPT;
BEGIN
	SELECT DEPARTMENT_ID, DEPARTMENT_NAME 
	INTO V_REC_DEPT.DEPT_ID, V_REC_DEPT.DEPT_NAME
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = 100;
	P(V_REC_DEPT.DEPT_ID||' '||V_REC_DEPT.DEPT_NAME);
END;

-- RECORD타입에 RECORD타입을 포함
DECLARE
	TYPE REC_EMP IS RECORD(
		EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE,
		EMP_FULLNAME VARCHAR2(50)
	);
	TYPE REC_DEPT IS RECORD(
		DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE,
		DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE,
		V_REC_EMP REC_EMP -- RECORD타입내의 RECORD타입
	);
	-- 레코드타입의 변수 선언
	V_REC_DEPT REC_DEPT;
BEGIN
	SELECT 
		D.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.FIRST_NAME||' '||E.LAST_NAME 
	INTO
		V_REC_DEPT.DEPT_ID, V_REC_DEPT.DEPT_NAME, V_REC_DEPT.V_REC_EMP.EMP_ID, V_REC_DEPT.V_REC_EMP.EMP_FULLNAME
	FROM DEPARTMENTS D, EMPLOYEES E
	WHERE 
		D.DEPARTMENT_ID = E.DEPARTMENT_ID
		AND
		E.EMPLOYEE_ID = 110;
	P(V_REC_DEPT.DEPT_ID||' '||V_REC_DEPT.DEPT_NAME);
	P(V_REC_DEPT.V_REC_EMP.EMP_ID||' '||V_REC_DEPT.V_REC_EMP.EMP_FULLNAME);
END;


-- COLLECTION

-- 1. 연관배열 (ASSOCIATIVE ARRAY)
-- 실무에서 연관배열내에 RECORD들을 담아서 많이 사용
DECLARE
	-- 연관배열 타입 생성
	-- KEY가 정수(PLS_INTEGER), 값이 VARCHAR2(20)
	TYPE AA_STRING IS TABLE OF VARCHAR2(20)
	INDEX BY PLS_INTEGER;
	-- 연관배열 타입의 변수 생성 
	V_AA_STRING AA_STRING;
BEGIN
	-- 인덱스는 1부터 시작
	V_AA_STRING(1) := '홍길동'; -- 키가 1, 값이 홍길동
	V_AA_STRING(2) := '강감찬'; -- 키가 2, 값이 강감찬
	V_AA_STRING(3) := '이순신'; -- 키가 3, 값이 이순신
	P(V_AA_STRING(1));
	P(V_AA_STRING(2));
	P(V_AA_STRING(3));
END;

-- RECORD들의 연관배열
DECLARE
	-- 키는 정수, 값은 부서테이블의 행인 연관배열
	TYPE AA_DEPT IS TABLE OF DEPARTMENTS%ROWTYPE
	INDEX BY PLS_INTEGER; 
	-- 연관배열 타입의 변수
	V_AA_DEPT AA_DEPT;
	V_DEPT50 DEPARTMENTS%ROWTYPE;
	V_DEPT60 DEPARTMENTS%ROWTYPE;
BEGIN
	SELECT * INTO V_DEPT50 FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = 50;
	SELECT * INTO V_DEPT60 FROM DEPARTMENTS
	WHERE DEPARTMENT_ID = 60;
	V_AA_DEPT(1) := V_DEPT50;
	V_AA_DEPT(2) := V_DEPT60;
	P(V_AA_DEPT(1).DEPARTMENT_ID||' '||V_AA_DEPT(1).DEPARTMENT_NAME);
	P(V_AA_DEPT(2).DEPARTMENT_ID||' '||V_AA_DEPT(2).DEPARTMENT_NAME);
END;

-- EMPLOYEES 테이블의 직원풀네임을 키로 하고 행을 값으로 하는 연관배열
DECLARE
	-- 키가 문자열, 값이 직원테이블의 행
	TYPE TYPE_AA IS TABLE OF EMPLOYEES%ROWTYPE
	INDEX BY VARCHAR2(50);
	-- 연관배열 타입 변수
	EMP_AA TYPE_AA;
	-- CURSOR 선언 : 결과행동들을 지정하는 포이터
	CURSOR CUR_EMP IS(
		SELECT * FROM EMPLOYEES
	);
	FULLNAME VARCHAR2(50);
BEGIN
	-- 커서가 가리키는 각 행에 대해서 반복
	FOR EACHROW IN CUR_EMP
	LOOP
		FULLNAME := EACHROW.FIRST_NAME||' '||EACHROW.LAST_NAME;
		-- 연관배열의 키가 FULLNAME
		EMP_AA(FULLNAME) := EACHROW;
		P(FULLNAME);
	END LOOP;
END;

-- 2. VARRAY
-- 모든 부서명을 갖는 VARRAY를 생성해서 출력
DECLARE
	-- 배열의 크기지정, 배열에 담길 값의 타입
	TYPE TYPE_VA IS VARRAY(100)
	OF DEPARTMENTS.DEPARTMENT_NAME%TYPE;
	-- VARRAY타입의 변수
	V_VA TYPE_VA;
BEGIN
	-- 비어있는 VARRAY 생성
	V_VA := TYPE_VA();
	-- (SELECT * FROM DEPARTMENTS) : 익명 커서
	FOR EACHROW IN (SELECT * FROM DEPARTMENTS)
	LOOP
		-- VARRAY 공간 추가
		V_VA.EXTEND;
		-- 추가된 공간에 부서명 저장
		V_VA(V_VA.LAST) := EACHROW.DEPARTMENT_NAME;
		P(V_VA(V_VA.LAST));
	END LOOP;
END;

-- 3. 중첩테이블
-- INDEX가 없는 연관배열

-- 모든 직원들의 정보를 저장하는 중첩테이블 생성 후 출력
DECLARE
	-- 중첩테이블 타입 생성
	TYPE TYPE_TBL IS TABLE OF EMPLOYEES%ROWTYPE;
	-- 중첩테이블 타입 변수 생성
	V_TBL TYPE_TBL;
BEGIN
	-- 비어있는 중첩테이블 생성
	V_TBL := TYPE_TBL();
	FOR EACHROW IN (SELECT * FROM EMPLOYEES)
	LOOP
		-- 중첩테이블에 공간 하나 추가
		V_TBL.EXTEND;
		V_TBL(V_TBL.LAST) := EACHROW;
		P(
			V_TBL(V_TBL.LAST).EMPLOYEE_ID||' '||
			V_TBL(V_TBL.LAST).FIRST_NAME||' '||
			V_TBL(V_TBL.LAST).LAST_NAME||' '||
			V_TBL(V_TBL.LAST).SALARY
		);
	END LOOP;
END;


